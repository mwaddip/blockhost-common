#cloud-config
# NFT Authentication Cloud-Init Template
# Variables (substituted by vm-generator.py):
#   ${VM_NAME}         - VM hostname
#   ${SIGNING_HOST}    - Host for signing URL ([ipv6] or ipv4)
#   ${USERNAME}        - Linux username
#   ${NFT_TOKEN_ID}    - Reserved NFT token ID
#   ${CHAIN_ID}        - Blockchain chain ID
#   ${NFT_CONTRACT}    - NFT contract address
#   ${RPC_URL}         - JSON-RPC endpoint URL
#   ${OTP_LENGTH}      - OTP code length
#   ${OTP_TTL}         - OTP time-to-live in seconds
#   ${SECRET_KEY}      - Random 64-char hex string for PAM module
#   ${SIGNING_DOMAIN}  - FQDN for Let's Encrypt (empty = HTTP-only mode)

hostname: ${VM_NAME}

packages:
  - qemu-guest-agent

users:
  - name: ${USERNAME}
    gecos: "nft=${NFT_TOKEN_ID}"
    groups: sudo
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL

write_files:
  - path: /etc/pam_web3/config.toml
    permissions: '0640'
    content: |
      [machine]
      id = "${VM_NAME}"
      secret_key = "${SECRET_KEY}"

      [auth]
      mode = "nft"
      nft_lookup = "passwd"
      signing_url = "http://${SIGNING_HOST}:8080"
      otp_length = ${OTP_LENGTH}
      otp_ttl_seconds = ${OTP_TTL}

      [blockchain]
      socket_path = "/run/web3-auth/web3-auth.sock"
      chain_id = ${CHAIN_ID}
      nft_contract = "${NFT_CONTRACT}"
      timeout_seconds = 10

  - path: /etc/web3-auth/config.toml
    permissions: '0640'
    content: |
      socket_path = "/run/web3-auth/web3-auth.sock"
      backend = "jsonrpc"
      default_chain_id = ${CHAIN_ID}
      default_contract = "${NFT_CONTRACT}"

      [jsonrpc]
      rpc_url = "${RPC_URL}"
      timeout_seconds = 30

  - path: /etc/pam.d/sshd
    content: |
      # Web3 NFT authentication for all users
      auth [success=done default=die] pam_web3.so

      # Standard account/session management
      account    required     pam_nologin.so
      @include common-account
      session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
      session    required     pam_loginuid.so
      session    optional     pam_keyinit.so force revoke
      @include common-session
      session    optional     pam_motd.so  motd=/run/motd.dynamic
      session    optional     pam_motd.so noupdate
      session    optional     pam_mail.so standard noenv
      session    required     pam_limits.so
      session    required     pam_env.so
      session    required     pam_env.so user_readenv=1 envfile=/etc/default/locale
      session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so open
      @include common-password

  - path: /etc/ssh/sshd_config.d/web3-only.conf
    content: |
      # Web3 authentication only - disable all other methods
      PubkeyAuthentication no
      PasswordAuthentication no
      KbdInteractiveAuthentication yes
      UsePAM yes
      AuthenticationMethods keyboard-interactive

  - path: /etc/signing-domain
    content: "${SIGNING_DOMAIN}"

  - path: /usr/local/bin/serve-signing-page.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      """Serve the signing page (HTTPS if Let's Encrypt cert exists, HTTP fallback)."""
      import http.server
      import socket
      import socketserver
      import ssl
      import sys

      SIGNING_PAGE = "/usr/share/libpam-web3/signing-page/index.html"


      class Handler(http.server.BaseHTTPRequestHandler):
          html = open(SIGNING_PAGE).read()

          def do_GET(self):
              self.send_response(200)
              self.send_header("Content-Type", "text/html; charset=utf-8")
              self.send_header("Content-Length", len(self.html.encode()))
              self.end_headers()
              self.wfile.write(self.html.encode())

          def log_message(self, fmt, *args):
              print(f"[{'HTTPS' if hasattr(self.request, 'getpeercert') else 'HTTP'}] {args[0]}")


      class DualStackServer(socketserver.TCPServer):
          address_family = socket.AF_INET6
          allow_reuse_address = True

          def server_bind(self):
              self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
              super().server_bind()


      def find_cert(domain_file="/etc/signing-domain"):
          """Find Let's Encrypt cert for the signing domain."""
          try:
              domain = open(domain_file).read().strip()
              if not domain:
                  return None, None
              cert = f"/etc/letsencrypt/live/{domain}/fullchain.pem"
              key = f"/etc/letsencrypt/live/{domain}/privkey.pem"
              import os
              if os.path.exists(cert) and os.path.exists(key):
                  return cert, key
          except FileNotFoundError:
              pass
          return None, None


      port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080
      cert, key = find_cert()

      with DualStackServer(("::", port), Handler) as httpd:
          if cert and key:
              ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
              ctx.load_cert_chain(cert, key)
              httpd.socket = ctx.wrap_socket(httpd.socket, server_side=True)
              print(f"Serving signing page on [::]:{port} (HTTPS)")
          else:
              print(f"Serving signing page on [::]:{port} (HTTP)")
          httpd.serve_forever()

  - path: /etc/systemd/system/web3-sign.service
    content: |
      [Unit]
      Description=Web3 Signing Page HTTP Server
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/bin/python3 /usr/local/bin/serve-signing-page.py 8080
      Restart=on-failure
      RestartSec=10

      [Install]
      WantedBy=multi-user.target

runcmd:
  - systemctl enable --now qemu-guest-agent
  - systemctl daemon-reload
  - systemctl enable --now web3-auth-svc

  # Obtain Let's Encrypt cert if domain available
  - |
    if [ -n "${SIGNING_DOMAIN}" ]; then
      apt-get update -qq && apt-get install -y -qq certbot > /dev/null 2>&1
      certbot certonly --standalone --non-interactive --agree-tos \
        --register-unsafely-without-email \
        -d "${SIGNING_DOMAIN}" || true
    fi

  # Upgrade signing URL to HTTPS if domain + cert available
  - |
    if [ -n "${SIGNING_DOMAIN}" ] && [ -f /etc/letsencrypt/live/${SIGNING_DOMAIN}/fullchain.pem ]; then
      sed -i 's|signing_url = "http://.*:8080"|signing_url = "https://${SIGNING_DOMAIN}:8080"|' /etc/pam_web3/config.toml
    fi

  - systemctl enable --now web3-sign
  - systemctl restart sshd

final_message: "Web3 NFT authentication configured after $UPTIME seconds"
